name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  APP_NAME: floating-cheatsheets

jobs:
  build-linux:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential debhelper devscripts
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    
    - name: Build Debian package
      run: |
        chmod +x build_deb.sh
        ./build_deb.sh
    
    - name: List built files for debugging
      run: |
        echo "Files in root directory:"
        ls -la *.deb || echo "No .deb files in root"
        echo "All .deb files in project:"
        find . -name "*.deb" -type f
    
    - name: Upload Debian package
      uses: actions/upload-artifact@v4
      with:
        name: debian-package
        path: "*.deb"

  build-windows:
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyinstaller
        if (Test-Path requirements.txt) { pip install -r requirements.txt }
    
    - name: Convert icon to ICO format
      run: |
        # Check if icon.ico already exists
        if (Test-Path "assets\icon.ico") {
          Write-Host "Icon file already exists, skipping conversion"
          exit 0
        }
        
        # Check if PNG icon exists
        if (-not (Test-Path "assets\icon.png")) {
          Write-Error "Source icon file assets\icon.png not found"
          exit 1
        }
        
        # Use PowerShell to convert PNG to ICO
        try {
          Add-Type -AssemblyName System.Drawing
          $img = [System.Drawing.Image]::FromFile("$pwd\assets\icon.png")
          $ico = [System.Drawing.Icon]::FromHandle(([System.Drawing.Bitmap]$img.GetThumbnailImage(256,256,$null,[System.IntPtr]::Zero)).GetHicon())
          $file = New-Object System.IO.FileStream("$pwd\assets\icon.ico", [System.IO.FileMode]::Create)
          $ico.Save($file)
          $file.Close()
          $img.Dispose()
          $ico.Dispose()
          Write-Host "Icon conversion successful"
        } catch {
          Write-Error "Icon conversion failed: $_"
          exit 1
        }
      shell: powershell
    
    - name: Build Windows executable
      run: |
        # Verify spec file exists
        if (-not (Test-Path "windows/build_windows.spec")) {
          Write-Error "Spec file not found at windows/build_windows.spec"
          exit 1
        }
        
        # Build with PyInstaller
        pyinstaller windows/build_windows.spec --clean --noconfirm
        
        # Verify build was successful
        if (-not (Test-Path "dist/floating-cheatsheets")) {
          Write-Error "Build failed - dist directory not created"
          exit 1
        }
        
        # Rename executable to have .exe extension on Windows if needed
        if ((Test-Path "dist/floating-cheatsheets/floating-cheatsheets") -and (-not (Test-Path "dist/floating-cheatsheets/floating-cheatsheets.exe"))) {
          Move-Item "dist/floating-cheatsheets/floating-cheatsheets" "dist/floating-cheatsheets/floating-cheatsheets.exe"
        }
        
        # List contents for debugging
        Write-Host "Contents of dist/floating-cheatsheets:"
        Get-ChildItem "dist/floating-cheatsheets" | ForEach-Object { Write-Host $_.Name }
      shell: powershell
    
    - name: Install NSIS
      run: |
        try {
          # Method 1: Use Chocolatey to install NSIS
          Write-Host "Installing NSIS via Chocolatey..."
          choco install nsis -y --no-progress
          
          # Verify installation
          $nsisPath = "C:\Program Files (x86)\NSIS"
          if (Test-Path "$nsisPath\makensis.exe") {
            Write-Host "NSIS installed successfully via Chocolatey"
            & "$nsisPath\makensis.exe" /VERSION
            
            # Add to environment for current session and subsequent steps
            $env:PATH = "$nsisPath;$env:PATH"
            "$nsisPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            throw "Chocolatey installation failed"
          }
        } catch {
          Write-Host "Chocolatey method failed, trying direct download..."
          
          # Method 2: Direct download and install
          $nsisUrl = "https://sourceforge.net/projects/nsis/files/NSIS%203/3.08/nsis-3.08.zip/download"
          $nsisZip = "$env:TEMP\nsis.zip"
          $nsisDir = "C:\nsis"
          
          Write-Host "Downloading NSIS portable..."
          Invoke-WebRequest -Uri $nsisUrl -OutFile $nsisZip -UserAgent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
          
          Write-Host "Extracting NSIS..."
          Expand-Archive -Path $nsisZip -DestinationPath $nsisDir -Force
          
          # Find makensis.exe in extracted folder
          $makeNsisPath = Get-ChildItem -Path $nsisDir -Name "makensis.exe" -Recurse | Select-Object -First 1
          if ($makeNsisPath) {
            $nsisPath = Split-Path -Parent (Join-Path $nsisDir $makeNsisPath)
            Write-Host "NSIS installed successfully at: $nsisPath"
            & "$nsisPath\makensis.exe" /VERSION
            
            # Add to environment
            $env:PATH = "$nsisPath;$env:PATH"
            "$nsisPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            Write-Error "NSIS installation failed completely"
            exit 1
          }
        }
      shell: powershell
    
    - name: Create Windows installer
      run: |
        # Verify the dist directory exists before creating installer
        if (-not (Test-Path "dist/floating-cheatsheets")) {
          Write-Error "dist/floating-cheatsheets directory not found"
          exit 1
        }
        
        # Show current directory structure for debugging
        Write-Host "Current directory structure:"
        Get-ChildItem -Recurse -Name | Select-Object -First 20
        
        # Verify required files exist
        Write-Host "Checking required files..."
        $requiredFiles = @("assets\icon.ico", "LICENSE", "windows\installer.nsi")
        foreach ($file in $requiredFiles) {
          if (Test-Path $file) {
            Write-Host "Found: $file"
          } else {
            Write-Host "Missing: $file"
          }
        }
        
        # Change to windows directory and create installer
        Set-Location windows
        Write-Host "Changed to windows directory: $(Get-Location)"
        
        # Verify installer script exists
        if (-not (Test-Path "installer.nsi")) {
          Write-Error "installer.nsi not found in windows directory"
          exit 1
        }
        
        # Create the installer using makensis
        Write-Host "Creating installer with NSIS..."
        Write-Host "NSIS Version:"
        makensis /VERSION
        
        Write-Host "Running makensis on installer.nsi..."
        makensis installer.nsi
        
        # Verify installer was created
        if (Test-Path "floating-cheatsheets-1.0.0-setup.exe") {
          Write-Host "Installer created successfully: floating-cheatsheets-1.0.0-setup.exe"
        } else {
          Write-Error "Installer creation failed"
          exit 1
        }
      shell: powershell
    
    - name: Upload Windows installer
      uses: actions/upload-artifact@v4
      with:
        name: windows-installer
        path: "windows/*.exe"

  release:
    needs: [build-linux, build-windows]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write
      actions: read
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Read version from VERSION file
      id: version
      run: |
        VERSION=$(cat VERSION | tr -d '\n\r' | xargs)
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $VERSION"
        
    - name: Increment version for hotfix
      id: new_version
      run: |
        CURRENT_VERSION="${{ steps.version.outputs.VERSION }}"
        # Increment patch version for hotfix
        IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
        NEW_PATCH=$((patch + 1))
        NEW_VERSION="${major}.${minor}.${NEW_PATCH}"
        echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"
        
        # Update VERSION file
        echo "$NEW_VERSION" > VERSION
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Commit version bump
        git add VERSION
        git commit -m "chore: bump version to v$NEW_VERSION (hotfix release)"
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
    
    - name: Display structure of downloaded files
      run: |
        echo "Current directory structure:"
        ls -la
        echo "Looking for artifacts:"
        find . -name "*.deb" -o -name "*.exe" | head -10
    
    - name: Extract latest release notes
      id: changelog
      run: |
        # Extract the latest version changelog from RELEASE_NOTES.md
        VERSION="${{ steps.version.outputs.VERSION }}"
        echo "Extracting changelog for version: $VERSION"
        
        # Get changelog content between the first version header and the next one
        CHANGELOG=$(awk -v version="$VERSION" '
          /^## v/ { 
            if (found) exit
            if ($0 ~ version) found=1
            next
          }
          found && /^## v/ { exit }
          found { print }
        ' RELEASE_NOTES.md | sed '/^\s*$/d' | head -n 50)
        
        # If no specific changelog found, use a default message
        if [ -z "$CHANGELOG" ]; then
          CHANGELOG="## What's New in v$VERSION
        
        - Cross-platform support (Linux and Windows)
        - Floating cheatsheet widget
        - Easy cheatsheet management
        - Customizable interface
        
        See [RELEASE_NOTES.md](https://github.com/${{ github.repository }}/blob/main/RELEASE_NOTES.md) for detailed changelog."
        fi
        
        # Save changelog to file for multi-line output
        echo "$CHANGELOG" > changelog.md
        echo "Changelog extracted successfully"
    
    - name: Create Release
      run: |
        VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"
        TAG_NAME="v$VERSION"
        
        # Find the actual paths of the built files
        DEB_FILE=$(find . -name "floating-cheatsheets_*.deb" | head -1)
        EXE_FILE=$(find . -name "floating-cheatsheets-*-setup.exe" | head -1)
        
        echo "Creating release for version: $VERSION"
        echo "Found DEB file: $DEB_FILE"
        echo "Found EXE file: $EXE_FILE"
        
        if [ -z "$DEB_FILE" ] || [ -z "$EXE_FILE" ]; then
          echo "Error: Missing build artifacts"
          echo "DEB file: $DEB_FILE"
          echo "EXE file: $EXE_FILE"
          exit 1
        fi
        
        # Check if release already exists
        if gh release view "$TAG_NAME" >/dev/null 2>&1; then
          echo "Release $TAG_NAME already exists, skipping creation"
          echo "Use a different version number to create a new release"
          exit 0
        fi
        
        # Create release notes with changelog
        echo "🚀 **Floating CheatSheets v$VERSION**" > release_notes.md
        echo "" >> release_notes.md
        echo "## Downloads" >> release_notes.md
        echo "- **Linux**: Download the \`.deb\` file for Debian/Ubuntu systems" >> release_notes.md
        echo "- **Windows**: Download the \`.exe\` installer for Windows systems" >> release_notes.md
        echo "" >> release_notes.md
        echo "## Installation" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Linux (Debian/Ubuntu)" >> release_notes.md
        echo "\`\`\`bash" >> release_notes.md
        echo "sudo dpkg -i floating-cheatsheets_${VERSION}_all.deb" >> release_notes.md
        echo "\`\`\`" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Windows" >> release_notes.md
        echo "Run the \`.exe\` installer and follow the installation wizard." >> release_notes.md
        echo "" >> release_notes.md
        echo "## Changelog" >> release_notes.md
        cat changelog.md >> release_notes.md
        echo "" >> release_notes.md
        echo "---" >> release_notes.md
        echo "" >> release_notes.md
        PREV_VERSION=$(echo $VERSION | awk -F. '{print $1"."$2"."$3-1}')
        echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/v${PREV_VERSION}...v$VERSION" >> release_notes.md
        
        # Create the release
        gh release create "$TAG_NAME" \
          --title "Floating CheatSheets v$VERSION" \
          --notes-file release_notes.md \
          "$DEB_FILE" \
          "$EXE_FILE"
        
        echo "Release v$VERSION created successfully!"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
